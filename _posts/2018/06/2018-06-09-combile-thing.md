---   
layout:     post  
title:      编译器版本差异
description: 遇到一个编译器的问题，很纠结。          
keywords: 技术
tags: [技术]  
categories: [技术]  
updateData:  23:40 2018/06/09
published: false  
---  



![](/images/2018/06/cb0287319eca4b67.png)


# 一、背景

这是一个计算机编程相关的技术文章。  


好久没有写技术文章了。  
之前我手上负责的有一个很老的系统，大概是微博年代的，后来视频复用了这套系统。  
这个系统有三四年没更新过了，最近由于业务需求，需要增加一个功能。  
我大概梳理了系统的架构，编写出了新的服务，搭建了测试环境并测试通过，发布时却遇到了服务起不来的问题。  
显然是系统版本太低，编译服务器版本太高，不兼容导致的。  


说起编译器，不管是在网上还是内部，大家经常会说到一句话：腾讯的技术不行了，至少支持一下c11也行呀，永远都是c98。  
看到这句话我笑了。  
这个不是一个编译器的问题，这个是背后千千万万服务器的问题。  
编译器升级了，编译出的程序在千千万万的古老服务器上是跑不起来的，想让跑起来也可以，但是成本太高。  
所以那些人想法还是太简单，很多事情并不是我们看到的表面现象：不就是XX吗？多简单。  
当然，如果你已经看透了一切，然后再说出这些，那你就不简单了。  


# 二、基本信息

这里有三个信息，一个是系统信息，一个是glic信息，一个是gcc信息。  
当然gcc信息可以忽略，那个编译时才需要，所以非编译机这个信息可能不准。  


编译机系统版本是3.10， 服务器系统版本是2.6。  
编译机glic版本是2.12，服务器系统版本是2.4。  
编译机gcc版本是4.4，服务器系统版本是2.95。  


说到版本号，其实这里有个潜规则的。  
版本号一般是三个数字，即x.y.z的格式。  
x代表主版本号，用于重大升级，一般不向下兼容。  
y代表次版本号，用于功能升级，向下兼容，但是会增加一些新功能。  
z代表发布版本号，用于优化升级，向下兼容，代表优化了性能，修复了BUG等等。  
这里我把最后的发布版本号隐藏了。  


说起版本号，那自然有人问系统是怎么找到自己需要的版本呢？  
这个在编译出的程序中，有个叫做`.dynamic`的段，用来指定需要的库和版本。  

![](/images/2018/06/20180609161252.png)



# 三、glibc符号的hash问题  


一般服务在低版本系统运行时遇到的第一个问题就是Floating point exception。  
不过作为老司机，这个问题在N年前就遇到过了。  


我们知道实际上程序里面一切都是符号。  
而符号是个字符串，这在查找符号时就会是一个大的性能问题了。   
为了解决这个问题，glibc自然使用了hash技术，先将符号hash为一个整数，然后进行链表查找。  


以前使用的HASH符号，现在使用了GNU_HASH。  
新版本编译不特殊说明，只有GNU_HASH。  
所以这种情况的解决方案就是指定使用两种hash技术。  
编译参数就是`-Wl,--hash-style=both`。  


# 四、静态库inline时的符号问题  














