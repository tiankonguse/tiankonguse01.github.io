---  
layout: post  
title: Strategy Pattern 学习
description: 之前只接触过简单的设计模式。现在了解 Loki库的时候，了解到Policy-based Design，发现类似的设计模式可以应用到我最近的一个项目中，于是学习一下。
keywords: c++, Loki, 设计模式, 策略模式, 设计模式
updateData:  17:07 2015/2/28
tags: [c++, Loki, 设计模式, 策略模式, 设计模式]
categories: [程序人生]
---  

##  背景  

年前我做了这样一个项目: 监控一个有状态的流程任务，状态是有向图。  
对于每个状态，依赖于前导状态，还要对后续状态做一些事。  
当时项目赶得急，只是大概讨论了一番状态图就开始编码了，后来重构为五层: 收集信息层，work层，定时任务层，告警层，持久化层。  
核心逻辑都落到了work层，共八个状态，写到一个类中，当时写了几个状态就达到几千行代码了，于是及时重构，最终整个work的代码保持在了2000行之内，但是那四十几个函数，看的我心里特别不舒服，一直在想该怎么重构呢？

最近了解 [Loki库][loki-HomePage] 时，了解到 [Policy-based Design][wiki-Policy-based-design]， 进而了解到 [Strategy Pattern][wiki-Strategy-pattern]， 发现我这个状态问题用类似于 Strategy Pattern 的设计模式就可以解决问题了吧。  
当然，我还不知道什么设计模式可以解决我的这个问题，看来真该抽空看基本设计模式的书了。  


## 策略模式简介

wiki 上的介绍如下：

>  
> 策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。  
> 比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。  
>  
  
  
简单的说策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。   


策略模式使得算法可以在不影响到客户端的情况下发生变化。  


使用策略模式可以把行为和环境分割开来。  
环境类负责维持和查询行为类，各种算法则在具体策略类（ConcreteStrategy）中提供。  
由于算法和环境独立开来，算法的增减、修改都不会影响环境和客户端。  
当出现新的促销折扣或现有的折扣政策出现变化时，只需要实现新的策略类，并在客户端登记即可。  
策略模式相当于"可插入式（Pluggable）的算法"。  


> 这里的算法可以理解为对数据进行一些处理，不一定要实现类似的功能。  
> 以前，解决这样的问题常使用条件判断(if 或 switch) 和 数组(映射)。  
> 但是那样使得环境与具体实现耦合在一起，修改一个算法可能会影响其他算法，维护代码比较困难。  



## 策略模式结构

策略模式是对算法的包装，是把使用算法的责任和算法本身分割开，委派给不同的对象管理。  
策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。  
用一句话来说，就是："准备一组算法，并将每一个算法封装起来，使得它们可以互换。"  

下面是一个示意性的策略模式结构图：

![策略模式结构图][wiki-Strategy-pattern-img]

这个模式涉及到三个角色：  

* 环境（Context）角色：持有一个Strategy类的引用。  
* 抽象策略（Strategy）角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。  
* 具体策略（ConcreteStrategy）角色：包装了相关的算法或行为。  


## 策略模式使用场景


在学习策略模式时，常问的一个问题是：为什么不能从策略模式中看出哪一个具体策略适用于哪一种情况呢？  

答案非常简单，策略模式并不负责做这个决定。  
换言之，应当由客户端自己决定在什么情况下使用什么具体策略角色。  
策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中"退休"的方便，策略模式并不决定在何时使用何种算法。  


在下面的情况下应当考虑使用策略模式：  

1. 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。  
2. 一个系统需要动态地在几种算法中选择一种。  
    那么这些算法可以包装到一个个的具体算法类里面，而这些具体算法类都是一个抽象算法类的子类。  
    换言之，这些具体算法类均有统一的接口，由于多态性原则，客户端可以选择使用任何一个具体算法类，并只持有一个数据类型是抽象算法类的对象。  
3. 一个系统的算法使用的数据不可以让客户端知道。  
    策略模式可以避免让客户端涉及到不必要接触到的复杂的和只与算法有关的数据。  
4. 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。  
    此时，使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句，并体现面向对象设计的概念。  


## 策略模式评价

策略模式有很多优点和缺点。  

### 优点

1. 策略模式提供了管理相关的算法族的办法。  
    策略类的等级结构定义了一个算法或行为族。  
        恰当使用继承可以把公共的代码移到父类里面，从而避免重复的代码。
2. 策略模式提供了可以替换继承关系的办法。  
    继承可以处理多种算法或行为。  
    如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。  
    但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。  
    决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。  
    继承使得动态改变算法或行为变得不可能。  
3. 使用策略模式可以避免使用多重条件转移语句。  
    多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。


### 缺点

1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。  
    这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。  
    换言之，策略模式只适用于客户端知道所有的算法或行为的情况。  
2. 策略模式造成很多的策略类。  
    有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。  
    换言之，可以使用享元模式来减少对象的数量。  

## 参考资料


* [设计模式（22）－Strategy Pattern][cnblogs-zhenyulu-82017]
* [设计模式 ( 十八 ) 策略模式Strategy（对象行为型）][csdn-hguisu-7558249]
* [我的实用设计模式之关于Policy-based design][cnblogs-procoder-1420362]


[loki-HomePage]: http://loki-lib.sourceforge.net/index.php?n=Main.HomePage
[wiki-Policy-based-design]: http://en.wikipedia.org/wiki/Policy-based_design
[wiki-Strategy-pattern]: http://en.wikipedia.org/wiki/Strategy_pattern
[wiki-Strategy-pattern-img]: http://tiankonguse.com/lab/cloudLink/baidupan.php?url=/1915453531/4290972155.png
[cnblogs-zhenyulu-82017]: http://www.cnblogs.com/zhenyulu/articles/82017.html
[csdn-hguisu-7558249]: http://blog.csdn.net/hguisu/article/details/7558249
[cnblogs-procoder-1420362]: http://www.cnblogs.com/procoder/archive/2009/03/24/1420362.html
